# pylint: disable=import-error
from VM_OrchestratorApp import MONGO_CLIENT
from VM_Orchestrator.settings import MONGO_INFO
from VM_OrchestratorApp.src.utils import slack

from datetime import datetime
import json

resources = MONGO_CLIENT[MONGO_INFO['DATABASE']][MONGO_INFO['RESOURCES_COLLECTION']]
observations = MONGO_CLIENT[MONGO_INFO['DATABASE']][MONGO_INFO['OBSERVATIONS_COLLECTION']]
vulnerabilities = MONGO_CLIENT[MONGO_INFO['DATABASE']][MONGO_INFO['VULNERABILITIES_COLLECTION']]
libraries_versions = MONGO_CLIENT[MONGO_INFO['DATABASE']]['libraries_versions']

def add_vulnerability(vulnerability):
    exists = vulnerabilities.find_one({'domain': vulnerability.domain, 'resource': vulnerability.target,
                                          'vulnerability_name': vulnerability.vulnerability_name,
                                          'language': vulnerability.language})
    if exists:
        vulnerabilities.update_one({'_id': exists.get('_id')}, {'$set': {
            'extra_info': vulnerability.custom_description,
            'last_seen': vulnerability.time,
            'image_string': vulnerability.image_string,
            'file_string': vulnerability.file_string
        }})
    else:
        resource = {
            'domain': vulnerability.domain,
            'resource': vulnerability.target,
            'vulnerability_name': vulnerability.vulnerability_name,
            'observation': vulnerability.get_json_observation(),
            'extra_info': vulnerability.custom_description,
            'image_string': vulnerability.image_string,
            'file_string': vulnerability.file_string,
            'date_found': vulnerability.time,
            'last_seen': vulnerability.time,
            'language': vulnerability.language,
            'cvss_score': vulnerability.cvss,
            'state': 'new'
        }
        vulnerabilities.insert_one(resource)
    return


# For flagging resources as "scanned"
def add_scanned_resources(scan_information_received):
    if scan_information_received['type'] == 'domain':
        for url in scan_information_received['target']:
            resource = resources.find_one({'domain': scan_information_received['domain'], 'subdomain': url, 'scanned': False, 'type': scan_information_received['type']})
            if resource is not None:
                resources.update_one({'_id': resource.get('_id')},
                {'$set': 
                    {
                    'scanned': True
                    }})
    else:
        if scan_information_received['type'] == 'url':
            #Url case, we search for url from mongo
            resource = resources.find_one({'domain': scan_information_received['domain'], 'url': scan_information_received['target'], 'scanned': False, 'type': scan_information_received['type']})
        else:
            #IP case, we will search for ip here instead of url
            resource = resources.find_one({'domain': scan_information_received['domain'], 'ip': scan_information_received['target'], 'scanned': False, 'type': scan_information_received['type']})
        if resource is not None:
            resources.update_one({'_id': resource.get('_id')},
            {'$set': 
                {
                'scanned': True
                }})

# Removing the scanned flag on all resources
def remove_scanned_flag():
    cursor = resources.find({})
    for document in cursor:
        resources.update_one({'_id': document.get('_id')}, {'$set': {
            'scanned': False
        }})


# This will return every url with http/https
def get_responsive_http_resources(target):
    subdomains = resources.find({'domain': target, 'has_urls': True, 'scanned': False, 'approved': True})
    subdomain_list = list()
    for subdomain in subdomains:
        for url_with_http in subdomain['url']:
            if url_with_http:
                current_subdomain = {
                    'domain': subdomain['domain'],
                    'ip': subdomain['ip'],
                    'subdomain': subdomain['subdomain'],
                    'url': url_with_http['url']
                }
                subdomain_list.append(current_subdomain)
    return subdomain_list

# Searches for vulnerability information in observations collection
def get_observation_for_object(vuln_name,language):
    finding_kb = observations.find_one({'TITLE': vuln_name, 'LANGUAGE': language})
    return finding_kb

# Returns a list similar to the one generated by the start csv file
def get_data_for_approved_scan():
    all_data = resources.find({'approved': True, 'scanned': False})
    information = list()
    for data in all_data:
        if data['type'] == 'url':
            resource = data['url']
        elif data['type'] == 'ip':
            resource = data['ip']
        else:
            resource = data['domain']
        information.append({
            'is_first_run': False,
            'invasive_scans': False,
            'language': 'eng',
            'type': data['type'],
            'priority': data['priority'],
            'exposition': data['exposition'],
            'domain': data['domain'],
            'resource': resource
        })
    import pandas as pd
    info_to_return = pd.DataFrame(information).drop_duplicates().to_dict('records')
    #info_to_return = [dict(t) for t in {tuple(sorted(d.items())) for d in information}]

    return info_to_return

# Returns a list similar to the one generated by the start csv file
def get_data_for_monitor():
    all_data = resources.find({'approved': True, 'scanned': False})
    information = list()
    for data in all_data:
        if data['type'] == 'url':
            resource = data['url']
        elif data['type'] == 'ip':
            resource = data['ip']
        else:
            resource = data['domain']
        information.append({
            'is_first_run': False,
            'invasive_scans': False,
            'language': 'eng',
            'type': data['type'],
            'priority': data['priority'],
            'exposition': data['exposition'],
            'domain': data['domain'],
            'resource': resource
        })
    import pandas as pd
    info_to_return = pd.DataFrame(information).drop_duplicates().to_dict('records')
    #info_to_return = [dict(t) for t in {tuple(sorted(d.items())) for d in information}]

    return info_to_return

def find_last_version_of_librarie(name):
    librarie = libraries_versions.find({'name':name})
    if librarie.count() != 0:
        return librarie[0]['version']
    else:
        return ''

def approve_resources(info):
    for resource in info['data']:
        exists = resources.find_one({'domain': resource['domain'], 'subdomain': resource['subdomain'], 'type':resource['type']})
        if not exists:
            print('RESOURCE %s FROM %s WAS IN THE CSV BUT NOT IN OUR DATABASE' % (resource['subdomain'], resource['domain']))
            continue
        resources.update_one({'_id': exists.get('_id')},
         {'$set': 
            {
            'approved': resource['approved'],
            'priority': resource['priority'],
            'exposition': resource['exposition'],
            'asset_value': resource['asset_value']
            }})

# ------------------- RECON -------------------
def add_simple_url_resource(scan_info):
    exists = resources.find_one({'domain': scan_info['domain'], 'url': scan_info['resource']})
    timestamp = datetime.now()
    if not exists:
        resource ={
                'domain': scan_info['domain'],
                'subdomain': None,
                'url': scan_info['resource'],
                'ip': None,
                'is_alive': True,
                'additional_info':{
                    'isp': None,
                    'asn': None,
                    'country': None,
                    'region': None,
                    'city': None,
                    'org': None,
                    'geoloc': '0 , 0'
                },
                'first_seen': timestamp,
                'last_seen': timestamp,
                'scanned': False,
                'type': scan_info['type'],
                'priority': scan_info['priority'],
                'exposition': scan_info['exposition'],
                'asset_value': None,
                'has_urls': False,
                'nmap_information': None,
                'approved': False,
                'reported': False
        }
        resources.insert_one(resource)
    else:
        resources.update_one({'_id': exists.get('_id')},
         {'$set': 
            {
            'last_seen': timestamp
            }})

def add_simple_ip_resource(scan_info):
    exists = resources.find_one({'domain': scan_info['domain'], 'ip': scan_info['resource']})
    timestamp = datetime.now()
    if not exists:
        resource ={
                'domain': scan_info['domain'],
                'subdomain': None,
                'url': None,
                'ip': scan_info['resource'],
                'is_alive': True,
                'additional_info':{
                    'isp': None,
                    'asn': None,
                    'country': None,
                    'region': None,
                    'city': None,
                    'org': None,
                    'geoloc': '0 , 0'
                },
                'first_seen': timestamp,
                'last_seen': timestamp,
                'scanned': False,
                'type': scan_info['type'],
                'priority': scan_info['priority'],
                'exposition': scan_info['exposition'],
                'asset_value': None,
                'has_urls': False,
                'nmap_information': None,
                'approved': False,
                'reported': False
        }
        resources.insert_one(resource)
    else:
        resources.update_one({'_id': exists.get('_id')},
         {'$set': 
            {
            'last_seen': timestamp
            }})


def add_resource(url_info, scan_info):
    exists = resources.find_one({'domain': url_info['domain'], 'subdomain': url_info['subdomain']})
    timestamp = datetime.now()
    ip = url_info['ip']
    if ip is not None:
        #Rare case in which an IP is actually a string
        if not ip.split('.')[0].isnumeric():
            ip = None
    if not exists:
        resource ={
                'domain': url_info['domain'],
                'subdomain': url_info['subdomain'],
                'url': '',
                'ip': ip,
                'is_alive': url_info['is_alive'],
                'additional_info':{
                    'isp': url_info['isp'],
                    'asn': url_info['asn'],
                    'country': url_info['country'],
                    'region': url_info['region'],
                    'city': url_info['city'],
                    'org': url_info['org'],
                    'geoloc': '%s , %s' % (str(url_info['lat']),str(url_info['lon']))
                },
                'first_seen': timestamp,
                'last_seen': timestamp,
                'scanned': False,
                'type': scan_info['type'],
                'priority': None,
                'exposition': None,
                'asset_value': None,
                'has_urls': False,
                'nmap_information': None,
                'approved': False,
                'reported': False
        }
        if not scan_info['is_first_run']:
            slack.send_new_resource_found("New resource found! %s" % url_info['subdomain'], '#vm-recon-module')
        resources.insert_one(resource)
    else:
        resources.update_one({'_id': exists.get('_id')},
         {'$set': 
            {
            'is_alive': url_info['is_alive'],
            'ip': ip,
            'additional_info':{
                    'isp': url_info['isp'],
                    'asn': url_info['asn'],
                    'country': url_info['country'],
                    'region': url_info['region'],
                    'city': url_info['city'],
                    'org': url_info['org'],
                    'geoloc': '%s , %s' % (str(url_info['lat']),str(url_info['lon']))
                },
            'last_seen': timestamp
            }})
    return


def get_alive_subdomains_from_target(target):
    subdomains = resources.find({'domain': target, 'is_alive': 'True', 'scanned': False, 'approved': True})
    subdomain_list = list()
    for subdomain in subdomains:
        current_subdomain = {
            'domain': subdomain['domain'],
            'subdomain': subdomain['subdomain']
        }
        subdomain_list.append(current_subdomain)
    return subdomain_list

def get_alive_subdomains_for_resolve(target):
    subdomains = resources.find({'domain': target, 'is_alive': 'True', 'scanned': False})
    subdomain_list = list()
    for subdomain in subdomains:
        current_subdomain = {
            'domain': subdomain['domain'],
            'subdomain': subdomain['subdomain']
        }
        subdomain_list.append(current_subdomain)
    return subdomain_list

def get_nmap_web_interfaces(scan_info):
    resource = resources.find_one({'domain': scan_info['domain'], 'ip': scan_info['resource'], 'type': scan_info['type']})
    to_send = list()
    if type(resource['nmap_information']) != list:
        if resource['nmap_information']['@portid'] == '80':
            to_send.append('http://'+scan_info['resource'])
        if resource['nmap_information']['@portid'] == '443':
            to_send.append('https://'+scan_info['resource'])
        return to_send
    else:
        for information in resource['nmap_information']:
            if information['@portid'] == '80':
                to_send.append('http://'+scan_info['resource'])
            if information['@portid'] == '443':
                to_send.append('https://'+scan_info['resource'])
    return to_send

def add_urls_from_aquatone(subdomain, has_urls, url_list):
    subdomain = resources.find_one({'subdomain': subdomain})
    resources.update_one({'_id': subdomain.get('_id')}, {'$set': {
        'has_urls': has_urls,
        'url': url_list}})
    return

def add_urls_from_httprobe(subdomain, url_to_add):
    subdomain = resources.find_one({'subdomain': subdomain['subdomain']})
    dict_to_add = {'url': url_to_add}
    if subdomain['url'] is None:
        list_to_add = list()
        list_to_add.append(dict_to_add)
        resources.update_one({'_id': subdomain.get('_id')}, {'$set': {
            'has_urls': True,
            'url': list_to_add}})
        return
    if dict_to_add not in subdomain['url']:
        new_list = subdomain['url']
        new_list.append(dict_to_add)    
        resources.update_one({'_id': subdomain.get('_id')}, {'$set': {
            'has_urls': True,
            'url': new_list}})
    return

def add_images_to_subdomain(subdomain, http_image, https_image):
    subdomain = resources.find_one({'subdomain': subdomain})
    resources.update_one({'_id': subdomain.get('_id')}, {'$set': {
        'http_image': http_image,
        'https_image': https_image}})
    return

def add_nmap_information_to_subdomain(scan_information, nmap_json):
    if scan_information['type'] == 'ip':
        resource = resources.find_one({'domain': scan_information['domain'], 'ip': scan_information['target']})
    elif scan_information['type'] == 'url':
        resource = resources.find_one({'domain': scan_information['domain'], 'url': scan_information['target']})
    else:
        resource = resources.find_one({'domain': scan_information['domain'], 'subdomain': scan_information['target']})
    if not resource:
        print('ERROR adding nmap information to resource, resource not found')
        return
    resources.update_one({'_id': resource.get('_id')},
         {'$set': 
            {
                'nmap_information': nmap_json
            }})
    return

def update_issue_if_needed(redmine_issue):
    target = redmine_issue.custom_fields.get(1).value
    vuln_name = redmine_issue.subject
    scanned_url = redmine_issue.custom_fields.get(2).value
    cvss_score = redmine_issue.custom_fields.get(10).value
    status = redmine_issue.status.name

    vulnerability = vulnerabilities.find_one({'vulnerability_name': vuln_name,
    'domain': target, 'resource': scanned_url})

    if not vulnerability:
        print('NOT FOUND')

    vulnerabilities.update_one({'_id': vulnerability.get('_id')}, {'$set': {
            'cvss_score': cvss_score 
        }})

    if status == 'Remediada':
        vulnerabilities.update_one({'_id': vulnerability.get('_id')}, {'$set': {
            'state': 'resolved' 
        }})
    elif status == 'Cerrada':
        vulnerabilities.update_one({'_id': vulnerability.get('_id')}, {'$set': {
            'state': 'closed' 
        }})
    return


def update_elasticsearch():
    new_resources = resources.find()
    resources_list = list()
    for resource in new_resources:
        if resource['url'] is None:
            resource_urls = None
        else:
            resource_urls = json.dumps(resource['url'])

        print(resource_urls)
        resources_list.append({
            'resource_id': str(resource['_id']),
            'resource_domain': resource['domain'],
            'resource_subdomain': resource['subdomain'],
            'resource_ip': resource['ip'],
            'resource_is_alive': bool(resource['is_alive']),
            'resource_additional_info':{
                'resource_isp': resource['additional_info']['isp'],
                'resource_asn': resource['additional_info']['asn'],
                'resource_country': resource['additional_info']['country'],
                'resource_region': resource['additional_info']['region'],
                'resource_city': resource['additional_info']['city'],
                'resource_org': resource['additional_info']['org'],
                'resource_geoloc': '0 , 0' if resource['additional_info']['geoloc'] == 'None , None' else resource['additional_info']['geoloc']
                },
            'resource_first_seen': resource['first_seen'],
            'resource_last_seen': resource['last_seen'],
            'resource_scanned': bool(resource['scanned']),
            'resource_type': resource['type'],
            'resource_priority': resource['priority'],
            'resource_exposition': resource['exposition'],
            'resource_asset_value': resource['asset_value'],
            'resource_has_urls': bool(resource['has_urls']),
            'resource_responsive_urls': None if resource_urls is None else resource_urls[0]["url"],
            'resource_nmap_information': resource['nmap_information']
        })

    ### VULNS ###
    new_vulnerabilities = vulnerabilities.find()
    vulnerabilities_list = list()
    for vuln in new_vulnerabilities:
        if not vuln['observation']:
            observation_data = {
                    'vulnerability_title': None,
                    'vulnerability_observation_title': None,
                    'vulnerability_observation_note': None,
                    'vulnerability_implication': None,
                    'vulnerability_recommendation_title': None,
                    'vulnerability_recommendation_note': None,
                    'vulnerability_severity': None
                }
        else:
            observation_data = {
                    'vulnerability_title': vuln['observation']['title'],
                    'vulnerability_observation_title': vuln['observation']['observation_title'],
                    'vulnerability_observation_note': vuln['observation']['observation_note'],
                    'vulnerability_implication': vuln['observation']['implication'],
                    'vulnerability_recommendation_title': vuln['observation']['recommendation_title'],
                    'vulnerability_recommendation_note': vuln['observation']['recommendation_note'],
                    'vulnerability_severity': vuln['observation']['severity']
                }
        vulnerabilities_list.append({
                'vulnerability_id': str(vuln['_id']),
                'vulnerability_domain': vuln['domain'],
                'vulnerability_subdomain': vuln['resource'],
                'vulnerability_vulnerability_name': vuln['vulnerability_name'],
                'vulnerability_observation': observation_data,
                'vulnerability_extra_info': vuln['extra_info'],
                'vulnerability_date_found': vuln['date_found'],
                'vulnerability_last_seen': vuln['last_seen'],
                'vulnerability_language': vuln['language'],
                'vulnerability_cvss_score': vuln['cvss_score'],
                'vulnerability_state': vuln['state']
            })

    # Import Elasticsearch package 
    from VM_OrchestratorApp import ELASTIC_CLIENT
    if ELASTIC_CLIENT is None:
        return 
    # Connect to the elastic cluster
    print('Adding resources to elasticsearch')
    for resource in resources_list:
        res = ELASTIC_CLIENT.index(index='resources',doc_type='_doc',id=resource['resource_id'],body=resource)
    print('Adding vulnerabilities to elasticsearch')
    for vuln in vulnerabilities_list:
        res = ELASTIC_CLIENT.index(index='vulnerabilities',doc_type='_doc',id=vuln['vulnerability_id'],body=vuln)


    

# TODO Temporary function for result revision
def get_vulnerabilities_for_email(scan_information):
    return_list = list()
    found_vulns = vulnerabilities.find({'domain': scan_information['domain']})
    for vuln in found_vulns:
            return_list.append(vuln)

    return  return_list

# TODO Temporary function for result revision
def get_resources_for_email(scan_information):
    return_list = list()
    found_resources = resources.find({'domain': scan_information['domain']})
    for resource in found_resources:
        res = {
            'domain': resource['domain'],
            'subdomain': resource['subdomain'],
            'url': resource['url'],
            'ip': resource['ip'],
            'isp': resource['additional_info']['isp'],
            'asn': resource['additional_info']['asn'],
            'country': resource['additional_info']['country'],
            'region': resource['additional_info']['region'],
            'city': resource['additional_info']['city'],
            'org': resource['additional_info']['org'],
            'geoloc': resource['additional_info']['geoloc'],
            'first_seen': resource['first_seen'],
            'last_seen': resource['last_seen'],
            'is_alive': resource['is_alive'],
            'has_urls': resource['has_urls'],
            'approved': resource['approved'],
            'scan_type': resource['type'],
            'priority': resource['priority'],
            'exposition': resource['exposition'],
            'asset_value': resource['asset_value']
        }
        return_list.append(res)
    
    return return_list